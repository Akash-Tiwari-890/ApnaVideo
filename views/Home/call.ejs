<% layout('layouts/boilerplate') -%>
<div class="container-fluid h-100">
    <div class="row h-100">
        <div class="col-md-9 d-flex flex-column p-3 bg-dark">
            <h2 class="text-center text-white mb-3">Meeting: <%= meetingCode %></h2>
            <div class="video-container position-relative flex-grow-1">
                <video id="mainVideo" autoplay playsinline class="w-100 h-100"></video>
                
                <video id="localVideo" autoplay playsinline muted class="position-absolute bottom-0 end-0 m-3 border border-3 border-info rounded-3" style="width: 200px; height: 150px; object-fit: cover; z-index: 10;"></video>
            </div>
            
            <div class="d-flex justify-content-center mt-3">
                <button id="toggleAudioBtn" class="btn btn-primary me-2">Mute Audio</button>
                <button id="toggleVideoBtn" class="btn btn-danger">Turn Off Video</button>
                <button id="toggleCutBtn" class="btn btn-danger ms-3">Cut</button>
                 
            </div>
        </div>

      <div class="col-md-3 d-flex flex-column p-3 bg-secondary">
    <h3 class="text-center text-white border-bottom pb-2">Chat</h3>
    <div class="chat-messages flex-grow-1 overflow-auto mb-2" id="chat-messages">
        <ul id="messages" class="list-unstyled p-0 m-0">
            <p class="text-white-50">No messages yet...</p>
        </ul>
    </div>
    <form id="form" class="mt-auto">
        <div class="input-group">
            <input type="text" id="input" class="form-control" placeholder="Type a message...">
            <button id="send-chat-btn" class="btn btn-primary">Send</button>
        </div>
    </form>
</div>
    </div>
</div>



<script src="/socket.io/socket.io.js"></script>
<script>
    const mainVideo = document.getElementById('mainVideo');
    const localVideo = document.getElementById('localVideo');
    const toggleAudioBtn = document.getElementById('toggleAudioBtn');
    const toggleVideoBtn = document.getElementById('toggleVideoBtn');
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const sendChatBtn = document.getElementById('send-chat-btn');
    
   

    let  localStream;
    const peers = {}; 
    let socket; 
    let mainRemoteUser = null; 

    const meetingCode = '<%= meetingCode %>';
    const urlParams = new URLSearchParams(window.location.search);
    const username = urlParams.get('username');
    const initialAudioState = urlParams.get('audio') === 'true';
    const initialVideoState = urlParams.get('video') === 'true';
    
    if (!username) {
        alert('Username not found. Redirecting to lobby.');
        window.location.href = `/apnavideo/loby?meetingCode=${meetingCode}`;
    }

    navigator.mediaDevices.getUserMedia({ 
        video:true, 
        audio:{
            noiseSuppression:true, 
            echoCancellation:true, 
            autoGainControl: true
        } 
    })
    .then(stream => {
        localStream = stream;
        localStream.getAudioTracks()[0].enabled = initialAudioState;
        localStream.getVideoTracks()[0].enabled = initialVideoState;
        
        // This is the fix: your local video now appears in the main box first.
        mainVideo.srcObject = localStream;
        // And your local video also appears in the small thumbnail.
        localVideo.srcObject = localStream;

        toggleAudioBtn.textContent = initialAudioState ? 'Mute Audio' : 'Unmute Audio';
        toggleVideoBtn.textContent = initialVideoState ? 'Turn Off Video' : 'Turn On Video';
        
        toggleAudioBtn.addEventListener('click', () => {
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                toggleAudioBtn.textContent = audioTrack.enabled ? 'Mute Audio' : 'Unmute Audio';
            }
        });
        
        toggleVideoBtn.addEventListener('click', () => {
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                toggleVideoBtn.textContent = videoTrack.enabled ? 'Turn Off Video' : 'Turn On Video';
            }
        });


        socket = io();

        socket.emit('join-lobby', { meetingCode, username });

        const form = document.getElementById('form');
  const input = document.getElementById('input');

  form.addEventListener('submit', (e) => {
    e.preventDefault();
    if (input.value) {
      socket.emit('chat message', input.value , username);
      input.value = '';
    }
  });

        socket.on('room-users', ({ users }) => {
            console.log('Current users in room:', users);
            users.forEach(userId => {
                createPeerConnection(userId, localStream, true);
            });
        });
      
        socket.on('user-joined', ({ userId }) => {
            createPeerConnection(userId, localStream, false);
        });

        socket.on('chat message', (msg , username) => {
    const item = document.createElement('li');
    // Add Bootstrap classes for a cleaner look
    item.classList.add('text-white', 'mb-2'); 
    item.textContent = `${username } : ${msg}`;
    messages.appendChild(item);
    window.scrollTo(0, document.body.scrollHeight);
});

       toggleCutBtn.addEventListener('click', () => {
           socket.disconnect();
              window.location.href = `/apnavideo/loby?meetingCode=${meetingCode}`;
        }); 
        socket.on('user-left', ({ userId }) => {
            console.log(`User left with ID: ${userId}`);
            if (peers[userId]) {
                if (mainRemoteUser === userId) {
                    // When a user in the main view leaves, swap your video back to the main view
                    mainVideo.srcObject = localStream; 
                    mainRemoteUser = null;
                }
                peers[userId].close();
                delete peers[userId];
            }
            removeVideoElement(userId);
        });

        socket.on('offer', async ({ offer, sourceUserId }) => {
            const peerConnection = createPeerConnection(sourceUserId, localStream, false);
            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            socket.emit('answer', {
                answer,
                targetUserId: sourceUserId
            });
        });

        socket.on('answer', ({ answer, sourceUserId }) => {
            const peerConnection = peers[sourceUserId];
            if (peerConnection) {
                peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
            }
        });

        socket.on('ice-candidate', ({ candidate, sourceUserId }) => {
            const peerConnection = peers[sourceUserId];
            if (peerConnection) {
                peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            }
        });
    })
    .catch(error => {
        console.error('Error accessing media devices.', error);
        alert('Could not access your camera and microphone. Please check your permissions.');
    });
    
    function createPeerConnection(userId, stream, isInitiator) {
        console.log(userId , stream , isInitiator)
        const peerConnection = new RTCPeerConnection({
            'iceServers': [
                {'urls': 'stun:stun.l.google.com:19302'}
            ]
        });

        stream.getTracks().forEach(track => {
            peerConnection.addTrack(track, stream);
        });

        peerConnection.ontrack = ({ streams: [remoteStream] }) => {
            if (mainRemoteUser === null) {
                mainVideo.srcObject = remoteStream;
                mainRemoteUser = userId;
            } else {
                console.log(`User ${userId} joined, but main video is already occupied.`);
            }
        };

        peerConnection.onicecandidate = event => {
            if (event.candidate) {
                socket.emit('ice-candidate', {
                    candidate: event.candidate,
                    targetUserId: userId
                });
            }
        };

        peers[userId] = peerConnection;

        if (isInitiator) {
            peerConnection.createOffer()
                .then(offer => peerConnection.setLocalDescription(offer))
                .then(() => {
                    socket.emit('offer', {
                        offer: peerConnection.localDescription,
                        targetUserId: userId
                    });
                });
        }
        return peerConnection;
    }
</script>